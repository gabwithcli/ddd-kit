// packages/ddd-kit/src/application/repos/abstract.es.repository.ts

import { AggregateRoot } from "../../domain";
import type { Tx } from "../../infra";
import { DomainEvent } from "../command";
import type { AggregateRepository } from "./aggregate.repository";

/**
 * Represents the result of loading events for an aggregate.
 */
export type EventStream = {
  events: DomainEvent<unknown>[];
  // The version is the count of events, used for optimistic concurrency.
  version: number;
};

// A new, type-safe contract for our aggregate class.
// It describes an object (the class constructor itself) that has a static method
// named `fromHistory`. This is exactly what our repository needs for rehydration.
export type RehydratableAggregate<AR extends AggregateRoot> = {
  fromHistory(id: string, events: DomainEvent<unknown>[]): AR;
};

/**
 * An abstract base class for Event Sourcing repositories.
 *
 * It fulfills the same `AggregateRepository` contract from the application's
 * point of view, but its internal mechanics are completely different from CRUD.
 * Instead of dealing with state, it deals with streams of historical events.
 *
 * @template AR - The type of Aggregate Root this repository manages.
 */
export abstract class AbstractEsRepository<AR extends AggregateRoot>
  implements AggregateRepository<AR>
{
  /**
   * Finds an aggregate by loading its entire history of events and replaying
   * them to reconstruct the current state.
   *
   * @param tx - The transaction context.
   * @param id - The ID of the aggregate to find (which corresponds to a stream ID).
   * @returns A promise resolving to the aggregate or null if its stream is empty.
   */
  public async findById(tx: Tx, id: string): Promise<AR | null> {
    // 1. Load the raw stream of events and the current version from the database.
    const stream = await this.loadEvents(tx, id);

    // If there are no events, the aggregate has never existed.
    if (stream.events.length === 0) {
      return null;
    }

    // 2. Rehydrate the aggregate by replaying its history.
    // The aggregate root MUST have a factory method like `fromHistory` for this to work.
    const AggregateClass = this.getAggregateClass();
    const aggregate = AggregateClass.fromHistory(id, stream.events);
    aggregate.version = stream.version;

    return aggregate;
  }

  /**
   * The main entry point for persisting an aggregate's changes.
   * In Event Sourcing, "saving" means appending the new, uncommitted events
   * from the aggregate to its event stream in the database.
   *
   * @param tx - The transaction context.
   * @param agg - The aggregate instance with pending changes (uncommitted events).
   */
  public async save(tx: Tx, agg: AR): Promise<void> {
    // 1. Get the pending events that were generated by the business operation.
    const uncommittedEvents = agg.pullEvents();

    // If no events were generated, there's nothing to save.
    if (uncommittedEvents.length === 0) {
      return;
    }

    // 2. Delegate to the concrete implementation to append these events to the store.
    // We pass the aggregate's current version, which is the expected number of events
    // already in the stream. This is our optimistic concurrency check.
    await this.appendEvents(tx, agg.id, agg.version, uncommittedEvents);

    // 3. Update the in-memory aggregate's version.
    agg.version += uncommittedEvents.length;
  }

  /**
   * A reference to the aggregate's constructor.
   * This is needed to call the static `fromHistory` method during rehydration.
   */
  protected abstract getAggregateClass(): RehydratableAggregate<AR>;

  /**
   * Loads the raw event data and stream version from the database.
   * Must be implemented by the concrete repository.
   *
   * @abstract
   * @protected
   */
  protected abstract loadEvents(tx: Tx, id: string): Promise<EventStream>;

  /**
   * Appends a list of new events to an event stream.
   * Must be implemented by the concrete repository to handle the `INSERT` logic
   * and the optimistic concurrency check on the stream version.
   *
   * @abstract
   * @protected
   */
  protected abstract appendEvents(
    tx: Tx,
    id: string,
    expectedVersion: number,
    events: DomainEvent<unknown>[]
  ): Promise<void>;
}
